"""
Markov Regime-Based Options Scanner - PRODUCTION READY v3.1
Senior Quantitative Developer Implementation

FIXES IN v3.1:
- CRITICAL: Fixed dividend yield parsing from yfinance (was returning 107% instead of 1.07%)
- Added sanity checks for dividend yields (max 15%)
- Added fallback to trailingAnnualDividendYield
- Added manual dividend yield overrides for major ETFs/stocks

Author: Senior Quant Dev
Date: 2026-01-28
Version: 3.1 (Dividend Yield Fix)
"""

import yfinance as yf
import pandas as pd
import numpy as np
import warnings
import os
import sys
from datetime import datetime, timedelta
from concurrent.futures import ThreadPoolExecutor, as_completed
from hmmlearn import hmm
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.preprocessing import StandardScaler

warnings.filterwarnings('ignore')

# ==================== THREAD CONTROL FOR WINDOWS STABILITY ====================
os.environ["OMP_NUM_THREADS"] = "1"
os.environ["MKL_NUM_THREADS"] = "1"
os.environ["OPENBLAS_NUM_THREADS"] = "1"
os.environ["NUMEXPR_NUM_THREADS"] = "1"

# ==================== CONFIGURATION ====================

TICKERS = ['SPY', 'QQQ', 'IWM', 'AAPL', 'MSFT', 'AMZN', 'NVDA', 'TSLA', 'META', 'GOOGL']
YEARS_HISTORY = 5
N_STATES = 3
ROLLING_VOL_WINDOW = 20
MIN_OPEN_INTEREST = 100
MAX_SPREAD_PCT = 0.05
ATM_RANGE_PCT = 0.15
BINOMIAL_STEPS = 50
COMMISSION_PER_CONTRACT = 0.65
OUTPUT_DIR = './options_screening_output/'
TOP_N = 30
MAX_WORKERS = 5
TRADING_DAYS_PER_YEAR = 252

STATE_LABELS = {0: 'Low Vol', 1: 'High Vol', 2: 'Crisis'}

# ==================== DIVIDEND YIELD OVERRIDES ====================
# Manual overrides for known tickers (approximate annual yields as of 2026)
# These are fallbacks when yfinance returns garbage data
DIVIDEND_YIELD_OVERRIDES = {
    'SPY': 0.013,   # ~1.3%
    'QQQ': 0.005,   # ~0.5%
    'IWM': 0.014,   # ~1.4%
    'AAPL': 0.005,  # ~0.5%
    'MSFT': 0.008,  # ~0.8%
    'AMZN': 0.0,    # No dividend
    'NVDA': 0.0003, # ~0.03%
    'TSLA': 0.0,    # No dividend
    'META': 0.004,  # ~0.4%
    'GOOGL': 0.005, # ~0.5%
}

# Maximum reasonable dividend yield (anything above this is likely an error)
MAX_REASONABLE_DIVIDEND_YIELD = 0.15  # 15%


# ==================== UTILITY FUNCTIONS ====================

def create_output_directory():
    """Create output directory if it doesn't exist"""
    if not os.path.exists(OUTPUT_DIR):
        os.makedirs(OUTPUT_DIR)
        print(f"‚úì Created output directory: {os.path.abspath(OUTPUT_DIR)}")
    return os.path.abspath(OUTPUT_DIR)


def download_risk_free_rate():
    """Download 10-year Treasury yield as risk-free rate"""
    try:
        tnx = yf.Ticker("^TNX")
        hist = tnx.history(period="5d")
        if hist.empty:
            print("‚ö† Could not fetch ^TNX, using default 4.5%")
            return 0.045
        rf_rate = hist['Close'].iloc[-1] / 100.0
        print(f"‚úì Risk-free rate (^TNX): {rf_rate*100:.2f}%")
        return rf_rate
    except Exception as e:
        print(f"‚ö† Error fetching risk-free rate: {e}, using default 4.5%")
        return 0.045


def download_historical_data(ticker, period="5y"):
    """Download historical price data"""
    try:
        tick = yf.Ticker(ticker)
        df = tick.history(period=period)
        if df.empty:
            return None
        return df
    except Exception as e:
        print(f"  ‚úó Error downloading {ticker}: {e}")
        return None


def calculate_features(df):
    """
    Calculate log returns and rolling volatility
    CRITICAL: Features are standardized for HMM stability
    """
    df = df.copy()
    df['Log_Return'] = np.log(df['Close'] / df['Close'].shift(1))
    df['Rolling_Vol'] = df['Log_Return'].rolling(window=ROLLING_VOL_WINDOW).std() * np.sqrt(252)
    df = df.dropna()
    
    scaler = StandardScaler()
    features_raw = df[['Log_Return', 'Rolling_Vol']].values
    features_standardized = scaler.fit_transform(features_raw)
    
    return df, features_standardized, scaler


def train_hmm(features, n_states=3):
    """Train Gaussian HMM on standardized features"""
    try:
        model = hmm.GaussianHMM(
            n_components=n_states,
            covariance_type="full",
            n_iter=100,
            random_state=42,
            verbose=False
        )
        model.fit(features)
        return model
    except Exception as e:
        print(f"  ‚úó HMM training failed: {e}")
        return None


def assign_state_labels(model, features):
    """
    Assign interpretable labels to HMM states based on average volatility
    """
    states = model.predict(features)
    vol_by_state = {}
    
    for state in range(model.n_components):
        state_mask = states == state
        if state_mask.sum() == 0:
            print(f"  ‚ö† State {state} has no observations, using global mean")
            vol_by_state[state] = features[:, 1].mean()
        else:
            avg_vol = features[state_mask, 1].mean()
            vol_by_state[state] = avg_vol
    
    sorted_states = sorted(vol_by_state.items(), key=lambda x: x[1])
    
    state_mapping = {
        sorted_states[0][0]: 0,  # Low Vol
        sorted_states[1][0]: 1,  # High Vol
        sorted_states[2][0]: 2   # Crisis
    }
    
    if len(set(state_mapping.values())) != N_STATES:
        raise ValueError("State mapping is not bijective!")
    
    return state_mapping


def calculate_regime_volatilities(df, states):
    """Calculate annualized volatility for each regime"""
    regime_vols = {}
    for state in range(N_STATES):
        state_mask = states == state
        state_returns = df.loc[state_mask, 'Log_Return']
        if len(state_returns) > 5:
            regime_vols[state] = state_returns.std() * np.sqrt(252)
        else:
            regime_vols[state] = df['Log_Return'].std() * np.sqrt(252)
    return regime_vols


def calendar_to_trading_days(calendar_days):
    """Convert calendar days to approximate trading days"""
    return int(calendar_days * (TRADING_DAYS_PER_YEAR / 365.0))


def project_forward_volatility(transition_matrix, current_state, regime_vols, calendar_days_to_expiry):
    """Project forward volatility using Markov transition matrix"""
    trading_days = calendar_to_trading_days(calendar_days_to_expiry)
    trading_days = max(1, trading_days)
    
    try:
        projected_probs = np.linalg.matrix_power(transition_matrix, trading_days)[current_state]
    except Exception as e:
        print(f"  ‚ö† Matrix power failed, using current state distribution: {e}")
        projected_probs = np.zeros(N_STATES)
        projected_probs[current_state] = 1.0
    
    forward_vol = sum(projected_probs[state] * regime_vols[state] for state in range(N_STATES))
    
    return forward_vol, projected_probs, trading_days


def remap_transition_matrix(transition_matrix, state_mapping):
    """Robustly remap transition matrix according to state labels"""
    n_states = transition_matrix.shape[0]
    remapped_tm = np.zeros_like(transition_matrix)
    
    if set(state_mapping.keys()) != set(range(n_states)):
        raise ValueError(f"State mapping incomplete: {state_mapping}")
    
    for i in range(n_states):
        for j in range(n_states):
            new_i = state_mapping[i]
            new_j = state_mapping[j]
            remapped_tm[new_i, new_j] = transition_matrix[i, j]
    
    row_sums = remapped_tm.sum(axis=1)
    if not np.allclose(row_sums, 1.0, atol=1e-6):
        print(f"  ‚ö† Warning: Transition matrix rows don't sum to 1: {row_sums}")
    
    return remapped_tm


def binomial_tree_american(S, K, T, r, sigma, option_type='call', steps=50, div_yield=0.0):
    """
    VECTORIZED Cox-Ross-Rubinstein Binomial Tree for American Options
    """
    if sigma <= 0 or T <= 0:
        intrinsic = max(0, S - K) if option_type == 'call' else max(0, K - S)
        return intrinsic
    
    dt = T / steps
    u = np.exp(sigma * np.sqrt(dt))
    d = 1 / u
    p = (np.exp((r - div_yield) * dt) - d) / (u - d)
    
    if p < 0 or p > 1:
        intrinsic = max(0, S - K) if option_type == 'call' else max(0, K - S)
        return intrinsic

    disc = np.exp(-r * dt)

    j = np.arange(steps + 1)
    asset_prices = S * (u ** (steps - j)) * (d ** j)

    if option_type == 'call':
        option_values = np.maximum(0, asset_prices - K)
    else:
        option_values = np.maximum(0, K - asset_prices)

    for i in range(steps - 1, -1, -1):
        j = np.arange(i + 1)
        S_t = S * (u ** (i - j)) * (d ** j)
        
        continuation = disc * (p * option_values[:-1] + (1 - p) * option_values[1:])
        
        if option_type == 'call':
            intrinsic = np.maximum(0, S_t - K)
        else:
            intrinsic = np.maximum(0, K - S_t)
            
        option_values = np.maximum(continuation, intrinsic)

    return option_values[0]


def get_dividend_yield(ticker_obj, ticker_symbol):
    """
    Get dividend yield from yfinance with robust error handling
    
    FIXES:
    1. Check multiple yfinance fields
    2. Validate yield is reasonable (< 15%)
    3. Fallback to manual overrides for known tickers
    4. Handle percentage vs decimal confusion
    
    Parameters:
    -----------
    ticker_obj : yf.Ticker
        The yfinance Ticker object
    ticker_symbol : str
        The ticker symbol (for fallback lookup)
    
    Returns:
    --------
    float : Dividend yield as decimal (e.g., 0.013 for 1.3%)
    """
    div_yield = None
    source = None
    
    try:
        info = ticker_obj.info
        
        # Try multiple fields in order of preference
        fields_to_try = [
            ('dividendYield', 'dividendYield'),
            ('trailingAnnualDividendYield', 'trailingAnnualDividendYield'),
            ('fiveYearAvgDividendYield', 'fiveYearAvgDividendYield'),
        ]
        
        for field_name, display_name in fields_to_try:
            raw_value = info.get(field_name)
            
            if raw_value is not None and raw_value > 0:
                # Check if value looks like a percentage (> 1) vs decimal (< 1)
                if raw_value > 1:
                    # Likely stored as percentage (e.g., 1.3 for 1.3%)
                    # But could also be corrupted data (e.g., 107)
                    if raw_value > 100:
                        # Definitely corrupted - skip this field
                        print(f"    ‚ö† {field_name} returned {raw_value}, likely corrupted")
                        continue
                    else:
                        # Convert percentage to decimal
                        div_yield = raw_value / 100.0
                        source = f"{display_name} (converted from %)"
                else:
                    # Already a decimal
                    div_yield = raw_value
                    source = display_name
                
                # Sanity check
                if div_yield <= MAX_REASONABLE_DIVIDEND_YIELD:
                    break
                else:
                    print(f"    ‚ö† {field_name} returned {div_yield*100:.1f}%, exceeds max reasonable")
                    div_yield = None
                    source = None
        
        # If still no valid yield, try calculating from dividends
        if div_yield is None:
            try:
                dividends = ticker_obj.dividends
                if not dividends.empty:
                    # Get last year's dividends
                    one_year_ago = datetime.now() - timedelta(days=365)
                    recent_divs = dividends[dividends.index >= one_year_ago]
                    
                    if not recent_divs.empty:
                        annual_div = recent_divs.sum()
                        current_price = info.get('regularMarketPrice') or info.get('currentPrice')
                        
                        if current_price and current_price > 0:
                            div_yield = annual_div / current_price
                            source = "calculated from dividends"
                            
                            if div_yield > MAX_REASONABLE_DIVIDEND_YIELD:
                                print(f"    ‚ö† Calculated yield {div_yield*100:.1f}% exceeds max")
                                div_yield = None
                                source = None
            except Exception as e:
                pass  # Silent fail, will use fallback
    
    except Exception as e:
        print(f"    ‚ö† Error fetching dividend info: {e}")
    
    # Fallback to manual override if needed
    if div_yield is None or div_yield > MAX_REASONABLE_DIVIDEND_YIELD:
        if ticker_symbol in DIVIDEND_YIELD_OVERRIDES:
            div_yield = DIVIDEND_YIELD_OVERRIDES[ticker_symbol]
            source = "manual override"
        else:
            div_yield = 0.0
            source = "default (no data)"
    
    print(f"    Dividend Yield: {div_yield*100:.2f}% (source: {source})")
    
    return div_yield


def filter_options_chain(options_df, current_price, min_oi, max_spread_pct, atm_range_pct):
    """Filter options based on liquidity and moneyness"""
    if options_df is None or options_df.empty:
        return pd.DataFrame()
    
    options_df = options_df[(options_df['bid'] > 0.01) & (options_df['ask'] > 0.01)].copy()
    
    if options_df.empty:
        return pd.DataFrame()
    
    options_df['mid_price'] = (options_df['bid'] + options_df['ask']) / 2
    options_df['spread_pct'] = (options_df['ask'] - options_df['bid']) / options_df['mid_price']
    
    filtered = options_df[
        (options_df['openInterest'] > min_oi) &
        (options_df['spread_pct'] < max_spread_pct) &
        (options_df['strike'] >= current_price * (1 - atm_range_pct)) &
        (options_df['strike'] <= current_price * (1 + atm_range_pct)) &
        (options_df['mid_price'] > 0.01)
    ].copy()
    
    return filtered


def process_single_ticker(ticker, rf_rate):
    """Process a single ticker: train HMM, get options, calculate opportunities"""
    try:
        print(f"\n{'='*60}")
        print(f"Processing {ticker}...")
        print(f"{'='*60}")
        
        # Download historical data
        df = download_historical_data(ticker, period=f"{YEARS_HISTORY}y")
        if df is None or len(df) < 252:
            print(f"  ‚úó Insufficient data for {ticker}")
            return None
        
        # Calculate features
        df, features_standardized, scaler = calculate_features(df)
        
        if len(features_standardized) < 100:
            print(f"  ‚úó Insufficient features after preprocessing for {ticker}")
            return None
        
        # Train HMM
        print(f"  Training HMM with {len(features_standardized)} observations...")
        model = train_hmm(features_standardized, n_states=N_STATES)
        
        if model is None:
            print(f"  ‚úó HMM training failed for {ticker}")
            return None
        
        # Predict states and assign labels
        states_raw = model.predict(features_standardized)
        state_mapping = assign_state_labels(model, features_standardized)
        states = np.array([state_mapping[s] for s in states_raw])
        
        # Current regime
        current_state = states[-1]
        current_regime = STATE_LABELS[current_state]
        print(f"  Current Regime: {current_regime}")
        
        # Calculate regime volatilities
        regime_vols = calculate_regime_volatilities(df, states)
        print(f"  Regime Volatilities: Low={regime_vols[0]*100:.1f}%, High={regime_vols[1]*100:.1f}%, Crisis={regime_vols[2]*100:.1f}%")
        
        # Get transition matrix and remap
        transition_matrix = model.transmat_
        transition_matrix = remap_transition_matrix(transition_matrix, state_mapping)
        
        # Get current price and dividend yield
        tick = yf.Ticker(ticker)
        current_price = df['Close'].iloc[-1]
        
        # FIXED: Use improved dividend yield function
        div_yield = get_dividend_yield(tick, ticker)
        
        print(f"  Current Price: ${current_price:.2f}")
        
        # Get options chain
        print(f"  Fetching options chain...")
        try:
            expirations = tick.options
            if not expirations:
                print(f"  ‚úó No options available for {ticker}")
                return None
        except Exception as e:
            print(f"  ‚úó Error fetching options for {ticker}: {e}")
            return None
        
        # Process each expiration
        opportunities = []
        
        for exp_date in expirations[:10]:
            try:
                opt_chain = tick.option_chain(exp_date)
                
                calls = filter_options_chain(
                    opt_chain.calls, current_price, 
                    MIN_OPEN_INTEREST, MAX_SPREAD_PCT, ATM_RANGE_PCT
                )
                
                puts = filter_options_chain(
                    opt_chain.puts, current_price,
                    MIN_OPEN_INTEREST, MAX_SPREAD_PCT, ATM_RANGE_PCT
                )
                
                exp_datetime = pd.to_datetime(exp_date)
                calendar_days_to_expiry = (exp_datetime - pd.Timestamp.now().normalize()).days
                
                if calendar_days_to_expiry < 1:
                    continue
                
                years_to_expiry = calendar_days_to_expiry / 365.0
                
                forward_vol, projected_probs, trading_days = project_forward_volatility(
                    transition_matrix, current_state, regime_vols, calendar_days_to_expiry
                )
                
                # Price calls
                for _, opt in calls.iterrows():
                    theoretical_price = binomial_tree_american(
                        S=current_price,
                        K=opt['strike'],
                        T=years_to_expiry,
                        r=rf_rate,
                        sigma=forward_vol,
                        option_type='call',
                        steps=BINOMIAL_STEPS,
                        div_yield=div_yield
                    )
                    
                    market_price = opt['mid_price']
                    expected_return = (theoretical_price - market_price - COMMISSION_PER_CONTRACT) / market_price
                    risk_adj_score = expected_return / forward_vol if forward_vol > 0 else 0
                    
                    opportunities.append({
                        'Ticker': ticker,
                        'Type': 'CALL',
                        'Strike': opt['strike'],
                        'Expiration': exp_date,
                        'Calendar_DTE': calendar_days_to_expiry,
                        'Trading_DTE': trading_days,
                        'Market_Price': market_price,
                        'Theoretical_Price': theoretical_price,
                        'Expected_Return': expected_return,
                        'Forward_Vol': forward_vol,
                        'Risk_Adj_Score': risk_adj_score,
                        'Current_Regime': current_regime,
                        'Open_Interest': opt['openInterest'],
                        'Spread_Pct': opt['spread_pct'],
                        'Div_Yield': div_yield
                    })
                
                # Price puts
                for _, opt in puts.iterrows():
                    theoretical_price = binomial_tree_american(
                        S=current_price,
                        K=opt['strike'],
                        T=years_to_expiry,
                        r=rf_rate,
                        sigma=forward_vol,
                        option_type='put',
                        steps=BINOMIAL_STEPS,
                        div_yield=div_yield
                    )
                    
                    market_price = opt['mid_price']
                    expected_return = (theoretical_price - market_price - COMMISSION_PER_CONTRACT) / market_price
                    risk_adj_score = expected_return / forward_vol if forward_vol > 0 else 0
                    
                    opportunities.append({
                        'Ticker': ticker,
                        'Type': 'PUT',
                        'Strike': opt['strike'],
                        'Expiration': exp_date,
                        'Calendar_DTE': calendar_days_to_expiry,
                        'Trading_DTE': trading_days,
                        'Market_Price': market_price,
                        'Theoretical_Price': theoretical_price,
                        'Expected_Return': expected_return,
                        'Forward_Vol': forward_vol,
                        'Risk_Adj_Score': risk_adj_score,
                        'Current_Regime': current_regime,
                        'Open_Interest': opt['openInterest'],
                        'Spread_Pct': opt['spread_pct'],
                        'Div_Yield': div_yield
                    })
                
            except Exception as e:
                print(f"  ‚ö† Error processing expiration {exp_date}: {e}")
                continue
        
        print(f"  ‚úì Found {len(opportunities)} qualifying contracts")
        
        result = {
            'ticker': ticker,
            'opportunities': opportunities,
            'states': states,
            'dates': df.index,
            'transition_matrix': transition_matrix,
            'current_state': current_state,
            'regime_vols': regime_vols,
            'div_yield': div_yield
        }
        
        return result
        
    except Exception as e:
        print(f"  ‚úó Fatal error processing {ticker}: {e}")
        import traceback
        traceback.print_exc()
        return None


def plot_regime_analysis(ticker, states, dates, transition_matrix, output_dir):
    """Plot regime probabilities over time"""
    try:
        fig, axes = plt.subplots(2, 1, figsize=(14, 10))
        
        colors = {0: 'green', 1: 'orange', 2: 'red'}
        color_list = [colors[s] for s in states]
        
        axes[0].scatter(dates, range(len(states)), c=color_list, alpha=0.6, s=10)
        axes[0].set_ylabel('Time Index')
        axes[0].set_title(f'{ticker} - Detected Market Regimes Over Time')
        axes[0].set_xlabel('Date')
        
        from matplotlib.patches import Patch
        legend_elements = [
            Patch(facecolor='green', label='Low Volatility'),
            Patch(facecolor='orange', label='High Volatility'),
            Patch(facecolor='red', label='Crisis Regime')
        ]
        axes[0].legend(handles=legend_elements, loc='upper right')
        
        sns.heatmap(transition_matrix, annot=True, fmt='.3f', cmap='YlOrRd', 
                    xticklabels=list(STATE_LABELS.values()),
                    yticklabels=list(STATE_LABELS.values()),
                    ax=axes[1], cbar_kws={'label': 'Probability'})
        axes[1].set_title(f'{ticker} - State Transition Matrix')
        axes[1].set_ylabel('From State')
        axes[1].set_xlabel('To State')
        
        plt.tight_layout()
        filepath = os.path.join(output_dir, f'{ticker}_hmm_regimes.png')
        plt.savefig(filepath, dpi=300, bbox_inches='tight')
        plt.close()
        
        return filepath
    except Exception as e:
        print(f"  ‚ö† Error creating plot for {ticker}: {e}")
        return None


def plot_combined_transition_matrices(all_results, output_dir):
    """Plot all transition matrices in a grid"""
    try:
        n_tickers = len(all_results)
        if n_tickers == 0:
            return None
            
        n_cols = 3
        n_rows = (n_tickers + n_cols - 1) // n_cols
        
        fig, axes = plt.subplots(n_rows, n_cols, figsize=(15, 5 * n_rows))
        axes = axes.flatten() if n_tickers > 1 else [axes]
        
        for idx, result in enumerate(all_results):
            ticker = result['ticker']
            tm = result['transition_matrix']
            
            sns.heatmap(tm, annot=True, fmt='.2f', cmap='YlOrRd',
                        xticklabels=list(STATE_LABELS.values()),
                        yticklabels=list(STATE_LABELS.values()),
                        ax=axes[idx], cbar_kws={'label': 'Probability'},
                        vmin=0, vmax=1)
            axes[idx].set_title(f'{ticker}')
        
        for idx in range(n_tickers, len(axes)):
            axes[idx].axis('off')
        
        plt.suptitle('Transition Matrices - All Tickers', fontsize=16, y=1.00)
        plt.tight_layout()
        
        filepath = os.path.join(output_dir, 'transition_matrices_heatmap.png')
        plt.savefig(filepath, dpi=300, bbox_inches='tight')
        plt.close()
        
        return filepath
    except Exception as e:
        print(f"  ‚ö† Error creating combined heatmap: {e}")
        return None


# ==================== MAIN EXECUTION ====================

def main():
    """Main execution function"""
    print("\n" + "="*80)
    print(" MARKOV OPTIONS SCANNER v3.1 - DIVIDEND YIELD FIX ".center(80, "="))
    print("="*80 + "\n")
    
    print("Architecture: ThreadPoolExecutor (I/O) + Sequential HMM (CPU)")
    print(f"Thread limits: OMP=1, MKL=1 (Windows compatibility)")
    print(f"Markov projection: Trading days ({TRADING_DAYS_PER_YEAR}/year)")
    print(f"Dividend yield: Multi-source with validation (max {MAX_REASONABLE_DIVIDEND_YIELD*100:.0f}%)\n")
    
    # Create output directory
    output_dir = create_output_directory()
    
    # Download risk-free rate
    rf_rate = download_risk_free_rate()
    
    # Process all tickers
    print(f"\n{'='*80}")
    print(f" PROCESSING {len(TICKERS)} TICKERS ".center(80, "="))
    print(f"{'='*80}")
    
    all_results = []
    all_opportunities = []
    
    for ticker in TICKERS:
        result = process_single_ticker(ticker, rf_rate)
        if result is not None:
            all_results.append(result)
            all_opportunities.extend(result['opportunities'])
            
            plot_path = plot_regime_analysis(
                result['ticker'],
                result['states'],
                result['dates'],
                result['transition_matrix'],
                output_dir
            )
            if plot_path:
                print(f"  ‚úì Plot saved: {os.path.basename(plot_path)}")
    
    # Check if we have any results
    if not all_opportunities:
        print("\n‚úó No opportunities found across all tickers!")
        return
    
    # Create DataFrame and rank opportunities
    print(f"\n{'='*80}")
    print(" RANKING OPPORTUNITIES ".center(80, "="))
    print(f"{'='*80}\n")
    
    df_opportunities = pd.DataFrame(all_opportunities)
    df_ranked = df_opportunities.sort_values('Risk_Adj_Score', ascending=False).head(TOP_N)
    
    # Save to CSV
    csv_path = os.path.join(output_dir, 'top_30_options_opportunities.csv')
    df_ranked.to_csv(csv_path, index=False)
    
    # Generate combined transition matrix plot
    heatmap_path = plot_combined_transition_matrices(all_results, output_dir)
    
    # Display results
    print(f"\n{'='*80}")
    print(f" TOP {TOP_N} OPTIONS OPPORTUNITIES ".center(80, "="))
    print(f"{'='*80}\n")
    
    pd.set_option('display.max_columns', None)
    pd.set_option('display.width', None)
    pd.set_option('display.max_colwidth', None)
    
    display_cols = ['Ticker', 'Type', 'Strike', 'Expiration', 'Trading_DTE', 
                    'Risk_Adj_Score', 'Expected_Return', 'Current_Regime', 'Market_Price', 'Div_Yield']
    print(df_ranked[display_cols].to_string(index=False))
    
    # Summary statistics
    print(f"\n{'='*80}")
    print(" SUMMARY STATISTICS ".center(80, "="))
    print(f"{'='*80}\n")
    
    print(f"Total contracts analyzed: {len(df_opportunities)}")
    print(f"Tickers processed successfully: {len(all_results)}/{len(TICKERS)}")
    
    # Dividend yield summary
    print(f"\nDividend Yields Used:")
    for result in all_results:
        print(f"  {result['ticker']}: {result['div_yield']*100:.2f}%")
    
    print(f"\nRegime Distribution in Top {TOP_N}:")
    print(df_ranked['Current_Regime'].value_counts())
    
    print(f"\nOption Type Distribution in Top {TOP_N}:")
    print(df_ranked['Type'].value_counts())
    
    print(f"\nTicker Distribution in Top {TOP_N}:")
    print(df_ranked['Ticker'].value_counts())
    
    print(f"\n{'='*80}")
    print(" OUTPUT FILES ".center(80, "="))
    print(f"{'='*80}\n")
    
    print(f"üìä CSV Report: {csv_path}")
    if heatmap_path:
        print(f"üìà Combined Heatmap: {heatmap_path}")
    print(f"\nüìÅ Individual regime plots saved in: {output_dir}")
    
    print(f"\n{'='*80}")
    print(" SCAN COMPLETE ".center(80, "="))
    print(f"{'='*80}\n")
    
    print("\nKEY METHODOLOGICAL NOTES:")
    print("=" * 60)
    print("1. Risk-Adjusted Score = Expected Return / Forward Volatility")
    print("2. Forward volatility projected using Markov chain in TRADING DAYS")
    print("3. Dividend yields validated (max 15%) with manual fallbacks")
    print("4. Single volatility per expiration (no IV surface modeling)")
    print("5. Commission of $0.65/contract included in expected returns")
    print("=" * 60)


if __name__ == "__main__":
    main()
